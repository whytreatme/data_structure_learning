
### **什么是 Complete Binary Tree（完全二叉树）？**

**完全二叉树（Complete Binary Tree）** 是一种特殊的二叉树，它满足以下两个条件：

1.  **所有层（从根节点开始计算），除了最后一层，必须被完全填满。**
2.  **最后一层的节点必须尽可能靠左对齐（即从左到右依次填充）。**

换句话说，完全二叉树是一棵“左对齐”的二叉树，在填充节点时，必须先填满当前层的左侧节点，直到这一层满了，才会开始填充下一层。

----------

### **完全二叉树的特点**

1.  **高度受限**：
    
    -   设完全二叉树有 nn 个节点，它的高度 hh 最多为： h=⌊log⁡2n⌋h = \lfloor \log_2 n \rfloor
    -   例如，若 n=7n = 7，则 h=⌊log⁡27⌋=2h = \lfloor \log_2 7 \rfloor = 2。
2.  **节点索引规律（适用于数组表示）**：
    
    -   如果将二叉树存储在 **数组** 中（通常用于**堆**），完全二叉树的索引有以下规律：
        -   对于索引为 ii 的节点：
            -   **左子节点索引**：2i+12i + 1
            -   **右子节点索引**：2i+22i + 2
            -   **父节点索引**：⌊i−12⌋\lfloor \frac{i-1}{2} \rfloor
    -   例如：
        
        ```
              1
            /   \
           2     3
          / \   /
         4   5 6
        
        ```
        
        在数组中的存储方式为：`[1, 2, 3, 4, 5, 6]`
        -   节点 `2`（索引 `1`）的左子节点是 `4`（索引 `3`），右子节点是 `5`（索引 `4`）。
        -   节点 `3`（索引 `2`）的左子节点是 `6`（索引 `5`），但没有右子节点。
3.  **比满二叉树更节省空间**：
    
    -   **满二叉树（Full Binary Tree）** 是所有层都被填满的二叉树，但完全二叉树可能缺少部分右子节点，因此比满二叉树更加灵活，节省空间。
4.  **堆（Heap）的基础结构**：
    
    -   **最大堆（Max Heap）和最小堆（Min Heap）** 一般都用**完全二叉树**实现，存储在数组中，并利用上面提到的索引关系进行高效操作。
5.  **父节点和子节点的关系明确**：
    
    -   由于它是**从左到右逐层填充**的，因此任意一个非叶子节点都能确定它的子节点。

----------

### **完全二叉树 vs. 其他二叉树**

**类型**

**定义**

**普通二叉树**

只要求每个节点最多有两个子节点，没有其他限制

**满二叉树（Full Binary Tree）**

每个节点要么有 0 个子节点（叶子节点），要么有 2 个子节点

**完全二叉树（Complete Binary Tree）**

除最后一层外，所有层必须填满，最后一层的节点必须靠左对齐

**完美二叉树（Perfect Binary Tree）**

每层都填满，并且所有叶子节点都在同一层

----------

### **示例**

1.  **完全二叉树示例**
    
    ```
          1
        /   \
       2     3
      / \   /
     4   5 6
    
    ```
    
    这个树是**完全二叉树**，因为：
    
    -   除了最后一层，每层都被填满。
    -   最后一层的叶子节点 `4, 5, 6` **靠左对齐**。
2.  **不是完全二叉树的情况**
    
    ```
          1
        /   \
       2     3
      /     /
     4     5
    
    ```
    
    这个树**不是完全二叉树**，因为：
    
    -   `2` 有左子节点 `4`，但**没有右子节点**，而 `3` 下面又有 `5`，导致右侧出现空缺，不符合完全二叉树的左对齐特性。

----------

### **应用**

1.  **堆排序（Heap Sort）**：基于完全二叉树结构的堆实现排序。
2.  **优先队列（Priority Queue）**：基于二叉堆（Binary Heap），也是完全二叉树。
3.  **二叉树的存储优化**：使用数组存储二叉树时，完全二叉树能够节省存储空间，避免浪费。

----------

### **总结**

-   **完全二叉树的核心特点**：所有层填满，最后一层靠左对齐。
-   **它比满二叉树少了一些严格要求，但比普通二叉树更有规则**，适合用数组存储。
-   **完全二叉树广泛用于堆数据结构（最大堆、最小堆）**，在排序、调度等算法中非常重要。

你提的这个问题很好！我们再来仔细分析一下。

**左子节点索引为 `2i + 1`，右子节点索引为 `2i + 2`** 的公式是针对**数组表示的完全二叉树**，而不是节点编号。我们一步步来理解这个公式是如何适用的。

----------

### **数组表示的完全二叉树**

当我们用**数组**存储一个完全二叉树时，我们按 **层序遍历（从上到下、从左到右）** 的顺序存储节点。例如：

```
        1
      /   \
     2     3
    / \   /
   4   5 6

```

按照层序遍历的顺序，这棵树的节点在数组中的存储方式如下：

```
索引:  0   1   2   3   4   5
值:    1   2   3   4   5   6

```

这里，索引 `i` 表示数组中的位置，而**节点的值**只是为了理解方便（实际索引从 0 开始）。

#### **索引关系推导**

-   **根节点**（索引 `0`）
    
    -   **左子节点** 索引 = `2 × 0 + 1 = 1`（即值为 `2`）
    -   **右子节点** 索引 = `2 × 0 + 2 = 2`（即值为 `3`）
-   **索引 `1`（值 `2`）**
    
    -   **左子节点** 索引 = `2 × 1 + 1 = 3`（即值为 `4`）
    -   **右子节点** 索引 = `2 × 1 + 2 = 4`（即值为 `5`）
-   **索引 `2`（值 `3`）**
    
    -   **左子节点** 索引 = `2 × 2 + 1 = 5`（即值为 `6`）
    -   **右子节点** 索引 = `2 × 2 + 2 = 6`（没有第 7 个节点，索引超出了数组范围）

----------

### **为什么 `2i + 1` 和 `2i + 2` 适用于数组？**

因为完全二叉树是**逐层、从左到右填充**的，所以**可以按层序遍历存入数组**，从而形成这样的索引关系。

但如果你用的是**节点编号**（比如树中的节点值是 `1, 2, 3, 4, 5, 6`），那么这些公式就不适用了——因为节点值**并不等于它在数组中的索引**！

----------

### **总结**

✔ **`2i + 1` 和 `2i + 2` 适用于数组索引，而不是树的节点值！**  
✔ **完全二叉树按层序遍历存入数组后，索引关系才成立！**  
✔ **数组索引从 `0` 开始，根节点 `i = 0`，然后按 `2i + 1` 和 `2i + 2` 计算左右子节点索引！**

你的疑问主要来自于 **“i = 1 为什么左子节点不是 2？”**，是因为你把**树的节点编号**当成了**数组的索引**，但实际上索引从 0 开始，而节点值和索引没有直接关系。
